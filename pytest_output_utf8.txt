============================= test session starts =============================
platform win32 -- Python 3.13.3, pytest-8.4.2, pluggy-1.6.0 -- C:\Python313\python.exe
cachedir: .pytest_cache
rootdir: C:\biz-stratosphere-main
plugins: anyio-4.10.0, asyncio-1.3.0
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 13 items

ml-service/tests/test_api.py::test_protected_ml_endpoint_without_auth PASSED [  7%]
ml-service/tests/test_api.py::test_protected_ml_endpoint_with_auth FAILED [ 15%]
ml-service/tests/test_api.py::test_ml_batch_predict_auth FAILED          [ 23%]
ml-service/tests/test_api.py::test_list_models_auth PASSED               [ 30%]
ml-service/tests/test_auth.py::test_get_current_user_valid_token FAILED  [ 38%]
ml-service/tests/test_auth.py::test_get_current_user_invalid_token FAILED [ 46%]
ml-service/tests/test_docker.py::test_docker_backend_health SKIPPED      [ 53%]
ml-service/tests/test_docker.py::test_docker_ollama_health SKIPPED (...) [ 61%]
ml-service/tests/test_docker.py::test_docker_db_retry_connection SKIPPED [ 69%]
ml-service/tests/test_health.py::test_health_check PASSED                [ 76%]
ml-service/tests/test_security.py::test_sql_injection_payload_in_features PASSED [ 84%]
ml-service/tests/test_security.py::test_invalid_payload_structure PASSED [ 92%]
ml-service/tests/test_security.py::test_unauthorized_token_rejection FAILED [100%]

================================== FAILURES ===================================
____________________ test_protected_ml_endpoint_with_auth _____________________

client = <starlette.testclient.TestClient object at 0x00000206C20DB890>

    def test_protected_ml_endpoint_with_auth(client):
        # This should fail from the model_service logic but pass auth (400 or 500 layer, not 401/403)
        response = client.post("/api/v1/ml/predict", json={
            "model_name": "invalid_model",
            "features": {"age": 30}
        })
    
        # Meaning auth succeeded, model validation failed
        assert response.status_code == 500
>       assert "not found" in response.json()["detail"].lower()
                              ^^^^^^^^^^^^^^^^^^^^^^^^^
E       KeyError: 'detail'

ml-service\tests\test_api.py:46: KeyError
---------------------------- Captured stdout setup ----------------------------
{"text": "DATABASE_URL not found. Skipping DB initialization.\\n", "record": {"elapsed": {"repr": "0:00:04.879801", "seconds": 4.879801}, "exception": null, "extra": {}, "file": {"name": "init_db.py", "path": "c:\\\\biz-stratosphere-main\\\\ml-service\\\\app\\\\db\\\\init_db.py"}, "function": "init_db", "level": {"icon": "\u26a0\ufe0f", "name": "WARNING", "no": 30}, "line": 17, "message": "DATABASE_URL not found. Skipping DB initialization.", "module": "init_db", "name": "app.db.init_db", "process": {"id": 22772, "name": "MainProcess"}, "thread": {"id": 5596, "name": "asyncio-portal-206c2260cd0"}, "time": {"repr": "2026-03-01 20:16:29.397117+05:30", "timestamp": 1772376389.397117}}}
---------------------------- Captured stdout call -----------------------------
{"text": "Model 'invalid_model' load failed: Registered Model with name=invalid_model not found\\n", "record": {"elapsed": {"repr": "0:00:04.910083", "seconds": 4.910083}, "exception": null, "extra": {"request_id": "cb9e8e71-139f-4cc6-a67e-fa56234f52d7", "endpoint": "/api/v1/ml/predict", "user_id": "unauthenticated"}, "file": {"name": "model_service.py", "path": "c:\\\\biz-stratosphere-main\\\\ml-service\\\\app\\\\services\\\\model_service.py"}, "function": "load_model", "level": {"icon": "\u274c", "name": "ERROR", "no": 40}, "line": 82, "message": "Model 'invalid_model' load failed: Registered Model with name=invalid_model not found", "module": "model_service", "name": "app.services.model_service", "process": {"id": 22772, "name": "MainProcess"}, "thread": {"id": 17120, "name": "AnyIO worker thread"}, "time": {"repr": "2026-03-01 20:16:29.427399+05:30", "timestamp": 1772376389.427399}}}\n{"text": "HTTP Exception: Model 'invalid_model' not found. Graceful fallback failed: Registered Model with name=invalid_model not found\\n", "record": {"elapsed": {"repr": "0:00:04.910783", "seconds": 4.910783}, "exception": null, "extra": {"request_id": "cb9e8e71-139f-4cc6-a67e-fa56234f52d7", "endpoint": "/api/v1/ml/predict", "user_id": "unauthenticated"}, "file": {"name": "exceptions.py", "path": "c:\\\\biz-stratosphere-main\\\\ml-service\\\\app\\\\core\\\\exceptions.py"}, "function": "http_exception_handler", "level": {"icon": "\u274c", "name": "ERROR", "no": 40}, "line": 16, "message": "HTTP Exception: Model 'invalid_model' not found. Graceful fallback failed: Registered Model with name=invalid_model not found", "module": "exceptions", "name": "app.core.exceptions", "process": {"id": 22772, "name": "MainProcess"}, "thread": {"id": 5596, "name": "asyncio-portal-206c2260cd0"}, "time": {"repr": "2026-03-01 20:16:29.428099+05:30", "timestamp": 1772376389.428099}}}\n{"text": "POST /api/v1/ml/predict - OK\\n", "record": {"elapsed": {"repr": "0:00:04.911112", "seconds": 4.911112}, "exception": null, "extra": {"request_id": "cb9e8e71-139f-4cc6-a67e-fa56234f52d7", "endpoint": "/api/v1/ml/predict", "user_id": "unauthenticated", "execution_time_ms": 14.21976089477539}, "file": {"name": "main.py", "path": "c:\\\\biz-stratosphere-main\\\\ml-service\\\\main.py"}, "function": "observability_middleware", "level": {"icon": "\u2139\ufe0f", "name": "INFO", "no": 20}, "line": 92, "message": "POST /api/v1/ml/predict - OK", "module": "main", "name": "main", "process": {"id": 22772, "name": "MainProcess"}, "thread": {"id": 5596, "name": "asyncio-portal-206c2260cd0"}, "time": {"repr": "2026-03-01 20:16:29.428428+05:30", "timestamp": 1772376389.428428}}}
_________________________ test_ml_batch_predict_auth __________________________

client = <starlette.testclient.TestClient object at 0x000002069DE28640>

    def test_ml_batch_predict_auth(client):
        response = client.post("/api/v1/ml/batch-predict", json=[{"age": 30}])
        # Missing query param model_name
>       assert response.status_code == 422
E       assert 403 == 422
E        +  where 403 = <Response [403 Forbidden]>.status_code

ml-service\tests\test_api.py:51: AssertionError
---------------------------- Captured stdout setup ----------------------------
{"text": "DATABASE_URL not found. Skipping DB initialization.\\n", "record": {"elapsed": {"repr": "0:00:05.459691", "seconds": 5.459691}, "exception": null, "extra": {}, "file": {"name": "init_db.py", "path": "c:\\\\biz-stratosphere-main\\\\ml-service\\\\app\\\\db\\\\init_db.py"}, "function": "init_db", "level": {"icon": "\u26a0\ufe0f", "name": "WARNING", "no": 30}, "line": 17, "message": "DATABASE_URL not found. Skipping DB initialization.", "module": "init_db", "name": "app.db.init_db", "process": {"id": 22772, "name": "MainProcess"}, "thread": {"id": 21948, "name": "asyncio-portal-206c2260b90"}, "time": {"repr": "2026-03-01 20:16:29.977007+05:30", "timestamp": 1772376389.977007}}}
---------------------------- Captured stdout call -----------------------------
{"text": "POST /api/v1/ml/batch-predict - OK\\n", "record": {"elapsed": {"repr": "0:00:05.469562", "seconds": 5.469562}, "exception": null, "extra": {"request_id": "06e86509-9d84-414d-bdd7-3ded5513eb31", "endpoint": "/api/v1/ml/batch-predict", "user_id": "unauthenticated", "execution_time_ms": 1.83868408203125}, "file": {"name": "main.py", "path": "c:\\\\biz-stratosphere-main\\\\ml-service\\\\main.py"}, "function": "observability_middleware", "level": {"icon": "\u2139\ufe0f", "name": "INFO", "no": 20}, "line": 92, "message": "POST /api/v1/ml/batch-predict - OK", "module": "main", "name": "main", "process": {"id": 22772, "name": "MainProcess"}, "thread": {"id": 21948, "name": "asyncio-portal-206c2260b90"}, "time": {"repr": "2026-03-01 20:16:29.986878+05:30", "timestamp": 1772376389.986878}}}
______________________ test_get_current_user_valid_token ______________________

self = <jose.backends.cryptography_backend.CryptographyRSAKey object at 0x00000206C213B620>
key = b'your-supabase-jwt-secret-here', algorithm = 'RS256'
cryptography_backend = <function default_backend at 0x000002069DADA8E0>

    def __init__(self, key, algorithm, cryptography_backend=default_backend):
        if algorithm not in ALGORITHMS.RSA:
            raise JWKError("hash_alg: %s is not a valid hash algorithm" % algorithm)
    
        self.hash_alg = {
            ALGORITHMS.RS256: self.SHA256,
            ALGORITHMS.RS384: self.SHA384,
            ALGORITHMS.RS512: self.SHA512,
        }.get(algorithm)
        self._algorithm = algorithm
    
        self.padding = {
            ALGORITHMS.RSA1_5: self.RSA1_5,
            ALGORITHMS.RSA_OAEP: self.RSA_OAEP,
            ALGORITHMS.RSA_OAEP_256: self.RSA_OAEP_256,
        }.get(algorithm)
    
        self.cryptography_backend = cryptography_backend
    
        # if it conforms to RSAPublicKey or RSAPrivateKey interface
        if (hasattr(key, "public_bytes") and hasattr(key, "public_numbers")) or hasattr(key, "private_bytes"):
            self.prepared_key = key
            return
    
        if isinstance(key, dict):
            self.prepared_key = self._process_jwk(key)
            return
    
        if isinstance(key, str):
            key = key.encode("utf-8")
    
        if isinstance(key, bytes):
            try:
                if key.startswith(b"-----BEGIN CERTIFICATE-----"):
                    self._process_cert(key)
                    return
    
                try:
>                   self.prepared_key = load_pem_public_key(key, self.cryptography_backend())
                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E                   ValueError: Unable to load PEM file. See https://cryptography.io/en/latest/faq/#why-can-t-i-import-my-pem-file for more details. MalformedFraming

C:\Users\ACER\AppData\Roaming\Python\Python313\site-packages\jose\backends\cryptography_backend.py:250: ValueError

During handling of the above exception, another exception occurred:

self = <jose.backends.cryptography_backend.CryptographyRSAKey object at 0x00000206C213B620>
key = b'your-supabase-jwt-secret-here', algorithm = 'RS256'
cryptography_backend = <function default_backend at 0x000002069DADA8E0>

    def __init__(self, key, algorithm, cryptography_backend=default_backend):
        if algorithm not in ALGORITHMS.RSA:
            raise JWKError("hash_alg: %s is not a valid hash algorithm" % algorithm)
    
        self.hash_alg = {
            ALGORITHMS.RS256: self.SHA256,
            ALGORITHMS.RS384: self.SHA384,
            ALGORITHMS.RS512: self.SHA512,
        }.get(algorithm)
        self._algorithm = algorithm
    
        self.padding = {
            ALGORITHMS.RSA1_5: self.RSA1_5,
            ALGORITHMS.RSA_OAEP: self.RSA_OAEP,
            ALGORITHMS.RSA_OAEP_256: self.RSA_OAEP_256,
        }.get(algorithm)
    
        self.cryptography_backend = cryptography_backend
    
        # if it conforms to RSAPublicKey or RSAPrivateKey interface
        if (hasattr(key, "public_bytes") and hasattr(key, "public_numbers")) or hasattr(key, "private_bytes"):
            self.prepared_key = key
            return
    
        if isinstance(key, dict):
            self.prepared_key = self._process_jwk(key)
            return
    
        if isinstance(key, str):
            key = key.encode("utf-8")
    
        if isinstance(key, bytes):
            try:
                if key.startswith(b"-----BEGIN CERTIFICATE-----"):
                    self._process_cert(key)
                    return
    
                try:
                    self.prepared_key = load_pem_public_key(key, self.cryptography_backend())
                except ValueError:
>                   self.prepared_key = load_pem_private_key(key, password=None, backend=self.cryptography_backend())
                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E                   ValueError: Unable to load PEM file. See https://cryptography.io/en/latest/faq/#why-can-t-i-import-my-pem-file for more details. MalformedFraming

C:\Users\ACER\AppData\Roaming\Python\Python313\site-packages\jose\backends\cryptography_backend.py:252: ValueError

During handling of the above exception, another exception occurred:

encoded_header = b'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9'
encoded_claims = b'eyJzdWIiOiJ1c2VyLTEyMzQiLCJyb2xlIjoiYXV0aGVudGljYXRlZCJ9'
algorithm = 'RS256', key = 'your-supabase-jwt-secret-here'

    def _sign_header_and_claims(encoded_header, encoded_claims, algorithm, key):
        signing_input = b".".join([encoded_header, encoded_claims])
        try:
            if not isinstance(key, Key):
>               key = jwk.construct(key, algorithm)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

C:\Users\ACER\AppData\Roaming\Python\Python313\site-packages\jose\jws.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\ACER\AppData\Roaming\Python\Python313\site-packages\jose\jwk.py:79: in construct
    return key_class(key_data, algorithm)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <jose.backends.cryptography_backend.CryptographyRSAKey object at 0x00000206C213B620>
key = b'your-supabase-jwt-secret-here', algorithm = 'RS256'
cryptography_backend = <function default_backend at 0x000002069DADA8E0>

    def __init__(self, key, algorithm, cryptography_backend=default_backend):
        if algorithm not in ALGORITHMS.RSA:
            raise JWKError("hash_alg: %s is not a valid hash algorithm" % algorithm)
    
        self.hash_alg = {
            ALGORITHMS.RS256: self.SHA256,
            ALGORITHMS.RS384: self.SHA384,
            ALGORITHMS.RS512: self.SHA512,
        }.get(algorithm)
        self._algorithm = algorithm
    
        self.padding = {
            ALGORITHMS.RSA1_5: self.RSA1_5,
            ALGORITHMS.RSA_OAEP: self.RSA_OAEP,
            ALGORITHMS.RSA_OAEP_256: self.RSA_OAEP_256,
        }.get(algorithm)
    
        self.cryptography_backend = cryptography_backend
    
        # if it conforms to RSAPublicKey or RSAPrivateKey interface
        if (hasattr(key, "public_bytes") and hasattr(key, "public_numbers")) or hasattr(key, "private_bytes"):
            self.prepared_key = key
            return
    
        if isinstance(key, dict):
            self.prepared_key = self._process_jwk(key)
            return
    
        if isinstance(key, str):
            key = key.encode("utf-8")
    
        if isinstance(key, bytes):
            try:
                if key.startswith(b"-----BEGIN CERTIFICATE-----"):
                    self._process_cert(key)
                    return
    
                try:
                    self.prepared_key = load_pem_public_key(key, self.cryptography_backend())
                except ValueError:
                    self.prepared_key = load_pem_private_key(key, password=None, backend=self.cryptography_backend())
            except Exception as e:
>               raise JWKError(e)
E               jose.exceptions.JWKError: Unable to load PEM file. See https://cryptography.io/en/latest/faq/#why-can-t-i-import-my-pem-file for more details. MalformedFraming

C:\Users\ACER\AppData\Roaming\Python\Python313\site-packages\jose\backends\cryptography_backend.py:254: JWKError

During handling of the above exception, another exception occurred:

    def test_get_current_user_valid_token():
        # Create a valid token
        payload = {"sub": "user-1234", "role": "authenticated"}
>       token = jwt.encode(payload, settings.SUPABASE_JWT_SECRET, algorithm=settings.JWT_ALGORITHM)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ml-service\tests\test_auth.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\ACER\AppData\Roaming\Python\Python313\site-packages\jose\jwt.py:63: in encode
    return jws.sign(claims, key, headers=headers, algorithm=algorithm)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\ACER\AppData\Roaming\Python\Python313\site-packages\jose\jws.py:47: in sign
    signed_output = _sign_header_and_claims(encoded_header, encoded_payload, algorithm, key)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

encoded_header = b'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9'
encoded_claims = b'eyJzdWIiOiJ1c2VyLTEyMzQiLCJyb2xlIjoiYXV0aGVudGljYXRlZCJ9'
algorithm = 'RS256', key = 'your-supabase-jwt-secret-here'

    def _sign_header_and_claims(encoded_header, encoded_claims, algorithm, key):
        signing_input = b".".join([encoded_header, encoded_claims])
        try:
            if not isinstance(key, Key):
                key = jwk.construct(key, algorithm)
            signature = key.sign(signing_input)
        except Exception as e:
>           raise JWSError(e)
E           jose.exceptions.JWSError: Unable to load PEM file. See https://cryptography.io/en/latest/faq/#why-can-t-i-import-my-pem-file for more details. MalformedFraming

C:\Users\ACER\AppData\Roaming\Python\Python313\site-packages\jose\jws.py:167: JWSError
_____________________ test_get_current_user_invalid_token _____________________

self = <jose.backends.cryptography_backend.CryptographyRSAKey object at 0x00000206C22625D0>
key = b'wrong-secret', algorithm = 'RS256'
cryptography_backend = <function default_backend at 0x000002069DADA8E0>

    def __init__(self, key, algorithm, cryptography_backend=default_backend):
        if algorithm not in ALGORITHMS.RSA:
            raise JWKError("hash_alg: %s is not a valid hash algorithm" % algorithm)
    
        self.hash_alg = {
            ALGORITHMS.RS256: self.SHA256,
            ALGORITHMS.RS384: self.SHA384,
            ALGORITHMS.RS512: self.SHA512,
        }.get(algorithm)
        self._algorithm = algorithm
    
        self.padding = {
            ALGORITHMS.RSA1_5: self.RSA1_5,
            ALGORITHMS.RSA_OAEP: self.RSA_OAEP,
            ALGORITHMS.RSA_OAEP_256: self.RSA_OAEP_256,
        }.get(algorithm)
    
        self.cryptography_backend = cryptography_backend
    
        # if it conforms to RSAPublicKey or RSAPrivateKey interface
        if (hasattr(key, "public_bytes") and hasattr(key, "public_numbers")) or hasattr(key, "private_bytes"):
            self.prepared_key = key
            return
    
        if isinstance(key, dict):
            self.prepared_key = self._process_jwk(key)
            return
    
        if isinstance(key, str):
            key = key.encode("utf-8")
    
        if isinstance(key, bytes):
            try:
                if key.startswith(b"-----BEGIN CERTIFICATE-----"):
                    self._process_cert(key)
                    return
    
                try:
>                   self.prepared_key = load_pem_public_key(key, self.cryptography_backend())
                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E                   ValueError: Unable to load PEM file. See https://cryptography.io/en/latest/faq/#why-can-t-i-import-my-pem-file for more details. MalformedFraming

C:\Users\ACER\AppData\Roaming\Python\Python313\site-packages\jose\backends\cryptography_backend.py:250: ValueError

During handling of the above exception, another exception occurred:

self = <jose.backends.cryptography_backend.CryptographyRSAKey object at 0x00000206C22625D0>
key = b'wrong-secret', algorithm = 'RS256'
cryptography_backend = <function default_backend at 0x000002069DADA8E0>

    def __init__(self, key, algorithm, cryptography_backend=default_backend):
        if algorithm not in ALGORITHMS.RSA:
            raise JWKError("hash_alg: %s is not a valid hash algorithm" % algorithm)
    
        self.hash_alg = {
            ALGORITHMS.RS256: self.SHA256,
            ALGORITHMS.RS384: self.SHA384,
            ALGORITHMS.RS512: self.SHA512,
        }.get(algorithm)
        self._algorithm = algorithm
    
        self.padding = {
            ALGORITHMS.RSA1_5: self.RSA1_5,
            ALGORITHMS.RSA_OAEP: self.RSA_OAEP,
            ALGORITHMS.RSA_OAEP_256: self.RSA_OAEP_256,
        }.get(algorithm)
    
        self.cryptography_backend = cryptography_backend
    
        # if it conforms to RSAPublicKey or RSAPrivateKey interface
        if (hasattr(key, "public_bytes") and hasattr(key, "public_numbers")) or hasattr(key, "private_bytes"):
            self.prepared_key = key
            return
    
        if isinstance(key, dict):
            self.prepared_key = self._process_jwk(key)
            return
    
        if isinstance(key, str):
            key = key.encode("utf-8")
    
        if isinstance(key, bytes):
            try:
                if key.startswith(b"-----BEGIN CERTIFICATE-----"):
                    self._process_cert(key)
                    return
    
                try:
                    self.prepared_key = load_pem_public_key(key, self.cryptography_backend())
                except ValueError:
>                   self.prepared_key = load_pem_private_key(key, password=None, backend=self.cryptography_backend())
                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E                   ValueError: Unable to load PEM file. See https://cryptography.io/en/latest/faq/#why-can-t-i-import-my-pem-file for more details. MalformedFraming

C:\Users\ACER\AppData\Roaming\Python\Python313\site-packages\jose\backends\cryptography_backend.py:252: ValueError

During handling of the above exception, another exception occurred:

encoded_header = b'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9'
encoded_claims = b'eyJzdWIiOiJ1c2VyLTEyMzQiLCJyb2xlIjoiYXV0aGVudGljYXRlZCJ9'
algorithm = 'RS256', key = 'wrong-secret'

    def _sign_header_and_claims(encoded_header, encoded_claims, algorithm, key):
        signing_input = b".".join([encoded_header, encoded_claims])
        try:
            if not isinstance(key, Key):
>               key = jwk.construct(key, algorithm)
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

C:\Users\ACER\AppData\Roaming\Python\Python313\site-packages\jose\jws.py:164: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\ACER\AppData\Roaming\Python\Python313\site-packages\jose\jwk.py:79: in construct
    return key_class(key_data, algorithm)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <jose.backends.cryptography_backend.CryptographyRSAKey object at 0x00000206C22625D0>
key = b'wrong-secret', algorithm = 'RS256'
cryptography_backend = <function default_backend at 0x000002069DADA8E0>

    def __init__(self, key, algorithm, cryptography_backend=default_backend):
        if algorithm not in ALGORITHMS.RSA:
            raise JWKError("hash_alg: %s is not a valid hash algorithm" % algorithm)
    
        self.hash_alg = {
            ALGORITHMS.RS256: self.SHA256,
            ALGORITHMS.RS384: self.SHA384,
            ALGORITHMS.RS512: self.SHA512,
        }.get(algorithm)
        self._algorithm = algorithm
    
        self.padding = {
            ALGORITHMS.RSA1_5: self.RSA1_5,
            ALGORITHMS.RSA_OAEP: self.RSA_OAEP,
            ALGORITHMS.RSA_OAEP_256: self.RSA_OAEP_256,
        }.get(algorithm)
    
        self.cryptography_backend = cryptography_backend
    
        # if it conforms to RSAPublicKey or RSAPrivateKey interface
        if (hasattr(key, "public_bytes") and hasattr(key, "public_numbers")) or hasattr(key, "private_bytes"):
            self.prepared_key = key
            return
    
        if isinstance(key, dict):
            self.prepared_key = self._process_jwk(key)
            return
    
        if isinstance(key, str):
            key = key.encode("utf-8")
    
        if isinstance(key, bytes):
            try:
                if key.startswith(b"-----BEGIN CERTIFICATE-----"):
                    self._process_cert(key)
                    return
    
                try:
                    self.prepared_key = load_pem_public_key(key, self.cryptography_backend())
                except ValueError:
                    self.prepared_key = load_pem_private_key(key, password=None, backend=self.cryptography_backend())
            except Exception as e:
>               raise JWKError(e)
E               jose.exceptions.JWKError: Unable to load PEM file. See https://cryptography.io/en/latest/faq/#why-can-t-i-import-my-pem-file for more details. MalformedFraming

C:\Users\ACER\AppData\Roaming\Python\Python313\site-packages\jose\backends\cryptography_backend.py:254: JWKError

During handling of the above exception, another exception occurred:

    def test_get_current_user_invalid_token():
        # Create an invalid token (wrong secret)
        payload = {"sub": "user-1234", "role": "authenticated"}
>       token = jwt.encode(payload, "wrong-secret", algorithm=settings.JWT_ALGORITHM)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ml-service\tests\test_auth.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\ACER\AppData\Roaming\Python\Python313\site-packages\jose\jwt.py:63: in encode
    return jws.sign(claims, key, headers=headers, algorithm=algorithm)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Users\ACER\AppData\Roaming\Python\Python313\site-packages\jose\jws.py:47: in sign
    signed_output = _sign_header_and_claims(encoded_header, encoded_payload, algorithm, key)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

encoded_header = b'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9'
encoded_claims = b'eyJzdWIiOiJ1c2VyLTEyMzQiLCJyb2xlIjoiYXV0aGVudGljYXRlZCJ9'
algorithm = 'RS256', key = 'wrong-secret'

    def _sign_header_and_claims(encoded_header, encoded_claims, algorithm, key):
        signing_input = b".".join([encoded_header, encoded_claims])
        try:
            if not isinstance(key, Key):
                key = jwk.construct(key, algorithm)
            signature = key.sign(signing_input)
        except Exception as e:
>           raise JWSError(e)
E           jose.exceptions.JWSError: Unable to load PEM file. See https://cryptography.io/en/latest/faq/#why-can-t-i-import-my-pem-file for more details. MalformedFraming

C:\Users\ACER\AppData\Roaming\Python\Python313\site-packages\jose\jws.py:167: JWSError
______________________ test_unauthorized_token_rejection ______________________

    def test_unauthorized_token_rejection():
        """Test that requests with an invalid authorization header format fail"""
        app.dependency_overrides = {} # Remove the auth mock
    
        with TestClient(app) as client:
            response = client.post(
                "/api/v1/ml/predict",
                json={"model_name": "churn_model", "features": {"age": 30}},
                headers={"Authorization": "Bearer not-a-valid-jwt"}
            )
    
            assert response.status_code == 401
>           assert "Could not validate credentials" in response.json().get("detail", "")
E           AssertionError: assert 'Could not validate credentials' in ''
E            +  where '' = <built-in method get of dict object at 0x00000206C0575640>('detail', '')
E            +    where <built-in method get of dict object at 0x00000206C0575640> = {'error': {'code': 'HTTP_401', 'message': 'Could not validate credentials: Error decoding token headers.', 'request_id': '2ab79706-ac7b-4785-bea4-629344ae1239'}, 'success': False}.get
E            +      where {'error': {'code': 'HTTP_401', 'message': 'Could not validate credentials: Error decoding token headers.', 'request_id': '2ab79706-ac7b-4785-bea4-629344ae1239'}, 'success': False} = json()
E            +        where json = <Response [401 Unauthorized]>.json

ml-service\tests\test_security.py:64: AssertionError
---------------------------- Captured stdout call -----------------------------
{"text": "DATABASE_URL not found. Skipping DB initialization.\\n", "record": {"elapsed": {"repr": "0:00:09.023190", "seconds": 9.02319}, "exception": null, "extra": {}, "file": {"name": "init_db.py", "path": "c:\\\\biz-stratosphere-main\\\\ml-service\\\\app\\\\db\\\\init_db.py"}, "function": "init_db", "level": {"icon": "\u26a0\ufe0f", "name": "WARNING", "no": 30}, "line": 17, "message": "DATABASE_URL not found. Skipping DB initialization.", "module": "init_db", "name": "app.db.init_db", "process": {"id": 22772, "name": "MainProcess"}, "thread": {"id": 32160, "name": "asyncio-portal-206c34e9040"}, "time": {"repr": "2026-03-01 20:16:33.540506+05:30", "timestamp": 1772376393.540506}}}\n{"text": "POST /api/v1/ml/predict - OK\\n", "record": {"elapsed": {"repr": "0:00:09.047866", "seconds": 9.047866}, "exception": null, "extra": {"request_id": "2ab79706-ac7b-4785-bea4-629344ae1239", "endpoint": "/api/v1/ml/predict", "user_id": "unauthenticated", "execution_time_ms": 13.861894607543945}, "file": {"name": "main.py", "path": "c:\\\\biz-stratosphere-main\\\\ml-service\\\\main.py"}, "function": "observability_middleware", "level": {"icon": "\u2139\ufe0f", "name": "INFO", "no": 20}, "line": 92, "message": "POST /api/v1/ml/predict - OK", "module": "main", "name": "main", "process": {"id": 22772, "name": "MainProcess"}, "thread": {"id": 32160, "name": "asyncio-portal-206c34e9040"}, "time": {"repr": "2026-03-01 20:16:33.565182+05:30", "timestamp": 1772376393.565182}}}
============================== warnings summary ===============================
..\Users\ACER\AppData\Roaming\Python\Python313\site-packages\pydantic\_internal\_config.py:323
  C:\Users\ACER\AppData\Roaming\Python\Python313\site-packages\pydantic\_internal\_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
FAILED ml-service/tests/test_api.py::test_protected_ml_endpoint_with_auth - K...
FAILED ml-service/tests/test_api.py::test_ml_batch_predict_auth - assert 403 ...
FAILED ml-service/tests/test_auth.py::test_get_current_user_valid_token - jos...
FAILED ml-service/tests/test_auth.py::test_get_current_user_invalid_token - j...
FAILED ml-service/tests/test_security.py::test_unauthorized_token_rejection
============== 5 failed, 5 passed, 3 skipped, 1 warning in 9.71s ==============
